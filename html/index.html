<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- (c) 2006-2007 Fabrizio Pollastri, Torino-Italy -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>AVC, Application View Controller</title>
<style type="text/css">
h1, .toc {
  text-align: center;}
h2 {
  margin-top: 1.5em; clear: both; text-align: center;}
h3 {
  margin-top: 1.5em; clear: both; text-decoration: underline;}
h5 {
  text-align: center; margin-top: 0px;}
p, li {
  text-align: justify;}
li {
  margin: 10px 0px 10px 0px;}
img {
  margin: 5px 0px 5px 10px; clear: right; float: right;}
.code {
  display: block; position: relative;
  width: ; margin: 5px 0px 30px 10px; padding: 10px;
  clear: right; float: right;
  border: solid green 2px; background-color: #eeeeee;}
.ilcode {
  padding: 2px 5px 2px 5px; cell-padding: 50px;
  border: solid green 1px; background-color: #eeeeee;
  font-family: Monospace; font-size: 12px;}
td {
  padding: 0px 4px 0px 4px;}
.fr {
  margin: 5px 0px 5px 10px; float: right;}
pre em, .ilcode em {
  color: red; font-style: normal;}
pre {
  padding: 10px;}
</style>
</head>
<body>


<h1>AVC, Application View Controller</h1>

<div class="toc">
  <a href="#what_is">What is</a> |
  <a href="#features">Features</a> |
  <a href="#quick_start">Quick start</a> |
  <a href="#download">Download</a> |
  <a href="#installation">Installation</a>
  <br><br>

  Reference manual:&nbsp;&nbsp;
  <a href="#common_part">Common part</a> |
  <a href="#gtk">GTK</a> |
  <a href="#qt3">Qt3</a> |
  <a href="#qt4">Qt4</a>
  <br><br>

  Examples&nbsp;&nbsp;
  GTK:
  <a href="#a_simple_example_for_gtk">Simple</a> |
  <a href="#a_counter_example_for_gtk">Counter</a> |
  <a href="#a_complex_example_for_gtk">Complex</a>
  Qt3:
  <a href="#a_simple_example_for_qt3">Simple</a> |
  <a href="#a_counter_example_for_qt3">Counter</a> |
  <a href="#a_complex_example_for_qt3">Complex</a>
  Qt4:
  <a href="#a_simple_example_for_qt4">Simple</a> |
  <a href="#a_counter_example_for_qt4">Counter</a> |
  <a href="#a_complex_example_for_qt4">Complex</a>
</div>  


<h3 id="what_is">What is</h3>

<p>Graphical User Interfaces (GUIs) are the easy way to input data to
an application sofware and to view data produced by the application.
The management of data exchanges between GUI and application is a
central problem in GUI programming, it absorbs a relevant part of the
programming effort. <b>AVC</b> is a
<a href="http://www.python.org/">python</a>
module that makes the programming of this data exchanges very easy,
it supports the principal widget toolkits.</p>

<p><b>AVC</b>, the Application View Controller, is a fully transparent and
automatic connector between the values displayed and entered by GUI
widgets and the variables of an application using the GUI.
The connection is bidirectional. If the application sets a new value
into a connected variable, AVC copies the new value into all widgets
connected to the variable. If a new value is entered by a widget, AVC
copies the new value into all other widgets connected the variable,
into the variable and optionally notifies the change to the application.
The connections are autogenerated by looking for matching names
between widget names and variable names.</p>

<p>The application is completely unaware of the presence of the connected
variables, it reads and writes them as normal variables. Only if the
application requires to be immediately notified when a connected
variable changes value, a notify handler must be added to the application.</p>

<p>AVC is released under the
<a href="http://www.gnu.org/licenses/gpl.txt">GNU General Public License</a>
.</p>

<p><em>Current version is AVC 0.1.0, alpha status, released 10-Jan-2007.
</em></p>

<p>Tested on Debian GNU/Linux Etch, FP 10-Jan-2007.</p>

<p>For any question, suggestion, contribution contact the author
<b>Fabrizio Pollastri</b>, e-mail: pollastri (at) iriti.cnr.it.</p>

<p>Th AVC web site is hosted at
<a href="http://avc.iriti.cnr.it/">http://avc.iriti.cnr.it/</a>.</p>


<h3 id="features">Features</h3>

<ul>
  <li>Fully transparent widgets-variables connections</li>
  <li>Automatic connection by matching widgets and variables names</li>
  <li>No application redesign</li>
  <li>Multiple widget toolkits support: GTK, Qt3, Qt4.</li>
  <li>Widgets support: button, check button, radio button, spin button,
      toggle button, text entry, text label.</li>
  <li>Variable types support: boolean, integer, float, string, list, tuple.</li>
  <li>Multiple widgets to one variable connection</li>
  <li>Dual update timing of variable value views: immediate or
      periodic.</li>
  <li>Python module written in pure python</li>
  <li>Free software (GNU GPL license)</li>
</ul>


<h3 id="quick_start">Quick start</h3>

<p>Essential instructions to get started with AVC. This instructions
are for the GTK toolkit, the usage with the other supported toolkits
is very similar. AVC module is supposed already installed. For full
details, see the documentation pages.</p>

<p>Import the AVC module for GTK.</p>

<span class="ilcode">from avc.avcgtk import *</span>

<p>Derive the application class from AVC class. Let suppose that the
application class name is "theApp".</p>

<span class="ilcode">class theApp(AVC):</span>

<p>Design the GUI with
<a href="http://glade.gnome.org/">Glade</a>
or create it in the application, naming
the widgets with the rule described below.</p>

<p>Define all variables to be connected in the application. Each
variable must have a name equal to the matching name of the widgets
that are to be connected to the variable. A widget matching name is
the widget name itself, if it does not contain a double underscore
'__', otherwise is the name part before the double underscore.</p>

<p>In the application, after the creation of GUI and all variables
to be connected, call the instance method 'avc_init'. Let suppose
that the application instance name is "the_app".</p>

<span class="ilcode">the_app.avc_init()</span>

<p>All is done for AVC. From this point, AVC takes full control over
data exchange between the connected variables and widgets.</p>


<h3 id="download">Download</h3>

<p>Download AVC tarball from
<a href="http://avc.iriti.cnr.it/dist/">
http://avc.iriti.cnr.it/dist/</a>
or from
<a href="http://cheeseshop.python.org/pypi">
http://cheeseshop.python.org/pypi</a>.</p>


<h3 id="installation">Installation</h3>

<p>To run <b>AVC</b>, <b>Python 2.2 or later</b> must already
be installed. The latest release is recommended. Python is available from
<a href="http://www.python.org/">http://www.python.org/</a>.</p>

<p>The first step is to expand the <tt>.tgz</tt> archive in a temporary
directory (<b>not</b> directly in Python's <tt>site-packages</tt>).
It contains a distutils setup file "setup.py".</p>

<ol class="arabic">
  <li><p>Open a shell.</p></li>
  <li><p>Unpack the tarball in a temporary directory (<b>not</b>
      directly in Python's <tt>site-packages</tt>). Commands:</p>
    <pre>tar zxf avc-X.Y.tar.gz<br></pre>
    <p>X and Y are the major and minor version numbers of the tarball.</p>
  </li>
</ol>
<ol start="2">
  <li>
    <p>Go to the directory created by expanding the tarball:</p>
    <pre>cd avc-X.Y<br></pre>
  </li>
  <li>
    <p>Get root privileges and install the package:</p>
    <pre>su<br>(enter root password)<br>python setup.py install<br></pre>
    <p>If the python executable isn't on your path, you'll have to
    specify the complete path, such as /usr/local/bin/python.</p>
  </li>
</ol>


<hr>
<h2>Reference manual</h2>

<h3 id="common_part">Common part</h3>

<p>This is the part of the reference manual common to all supported
widget toolkits: GTK, Qt3, Qt4.</p>

<h4>Names matching</h4>

<p>AVC connects widgets and variables using a names matching
procedure with the following rules.
</p>

<p>The matching name for a variable is the variable name itself.</p>

<table class="ilcode fr">
<caption>Examples of matching names</caption>
<tr><td><b>widget name</b></td><td><b>matching name</b></td></tr>
<tr><td>button_ok</td><td>button_ok</td></tr>
<tr><td>toggle__button</td><td>toggle</td></tr>
<tr><td>check_button_1</td><td>check_button_1</td></tr>
<tr><td>radio_button__2</td><td>radio_button</td></tr>
</table>

<p>The matching name for a widget is the widget name itself, if the
name does not contain a double underscore ('__'), otherwise the
matching name is the part of the widget name before the double underscore.
This allow to differentiate widget names for widgets that are to be
connected to the same variable.</p>

<p>Each widget having a matching name equal to a variable matching name
is connected to that variable.</p>

<p>A widget can be connected to one variable. A variable can be connected
to one or more widgets.</p>


<h4>Application class</h4>

<p>The application that uses AVC must be instantiated from an
application class that is derived from the <span class="ilcode">AVC</span>
class. Let suppose that the application class name is "theApp", the
application class statement will be
<span class="ilcode">class theApp(AVC):</span>.</p>

<p>The <span class="ilcode">AVC</span> class is derived from the builtin
<span class="ilcode">object</span> class that is the base of all new
style classes introduced with python 2.2. So, also the application
becomes a new style class.</p>


<h4>AVC initialization</h4>

<p>AVC start its job just after it is initialized. AVC initialization
can take place in the application after the creation of GUI and after
the instantiation of all variables to be connected. AVC initialization
is done by calling the instance method <span class="ilcode">avc_init</span>.
Let suppose that the application instance name is "the_app", the AVC
init statement will be <span class="ilcode">the_app.avc_init():</span>.</p>

<p>When the value of a connected variable is changed, the values displayed
by the widgets connected to it are updated by AVC in one of two allowed
modes: immediate or periodic. Mode selection is done at AVC initialization
specifying the "view_period" argument. If the argument is omitted, like in
<span class="ilcode">the_app.avc_init():</span>, it is assigned a default
value of 0.1 seconds, selecting a periodic views update with that period.
If the argument is assigned a value, like in
<span class="ilcode">the_app.avc_init(view_period=0.2):</span>, views will
be updated every "view_period" seconds.
If the argument is assigned to zero or to "None" value, like in
<span class="ilcode">the_app.avc_init(view_period=0):</span>, views will
be updated immediately after each change of the variable value.


<h4>Button widget</h4>

<p>The memoryless press button, its connected variable must be a boolean.
In normal state (button not pressed) the variable is "False", in
pressed state (mouse pointer over button and mouse button 1 pressed)
the variable is "True". Names for button widget in supported toolkits:
GTK "Button", Qt3 and Qt4 "PushButton" with toggle attribute off.</p>


<h4 id="check_button">Check button widget</h4>

<p>The behaviour of the check button widget is the same of the toggle
button widget. See <a href="#toggle_button">toggle button</a>.
Names for check button widget in supported toolkits:
GTK "CheckButton", Qt3 and Qt4 "CheckBox".</p>


<h4>Entry widget</h4>

<p>The text entry, its connected variable can be integer, float or
string. Text input must conform to the type of the connected variable.
If the connected variable is of type string, its value is copied
to the entry widget "as is", if type is integer or float, the value
is converted to string before copy.
Names for text entry widget in supported toolkits:
GTK "Entry", Qt3 and Qt4 "LineEdit".</p>


<h4>Label widget</h4>

<p>The text label, its connected variable can be boolean, integer,
float, string, list or tuple.  If the connected variable is of type
string, its value is copied to the label widget "as is", if type is
boolean, integer or float, the value is converted to string before copy.
If the label is created with a default text that is a valid python
formatting string, this is saved by AVC and used to format the label
text updates when the connected variable value changes. If the connected
variable type is list or tuple, a valid python formatting string
matching all the elements of list or tuple is mandatory in default
lebel text.</p>


<h4>Radio button widget</h4>

<p>The radio buttons come always in groups of two or more radio buttons.
Each radio button behaves like a
<a href="#check_button">check button</a>, but only one radio
button at a time can be checked in each group. A variable of type integer
can be connected to each group of radio buttons, its value is the index
of the checked radio button in the group.</p>


<h4>Spin button widget</h4>

<p>The spin button, its connected variable can be integer or float.
The GTK "SpinButton" support both types. On the contrary, Qt3 and Qt4
differentiate integer or float support with two widgets: "SpinBox"
and "DoubleSpinBox".
Names for spin button widget in supported toolkits:
GTK "SpinButton", Qt3 and Qt4 "SpinBox" for integer and "DoubleSpinBox"
for float. Remember that in python floats are always doubles.</p>


<h4 id="toggle_button">Toggle button widget</h4>

<p>The toggle button, a button with memory, its connected variable must
be a boolean. Each time the button is pressed, it changes its state:
from on to off or viceversa. In off state the variable is "False",
in on state the variable is "True".
Names for toggle button widget in supported toolkits:
GTK "ToggleButton", Qt3 and Qt4 "PushButton" with toggle attribute on.</p>


<h3 id="gtk">GTK</h3>

<p>This is the part of the reference manual specific to
<a href="http://www.gtk.org/">GTK</a>
widgets toolkit.</p>


<h4>Module dependencies</h4>

<p>AVC GTK depends on
<a href="http://www.pygtk.org">PyGTK</a>
the python wrapper for GTK libraries. AVC GTK imports the following modules
from PyGTK.</p>
<table class="ilcode">
<tr><td>import gtk</td></tr>
<tr><td>import gobject</td></tr>
</table>


<h4>Widget namimg</h4>

<p>Glade a GTK allow duplicated naming of widgets.</p>


<h3 id="qt3">Qt3</h3>

<p>This is the part of the reference manual specific to 
<a href="http://www.trolltech.com/products/qt/qt3">Qt3</a>
widgets toolkit.</p>


<h4>Module dependencies</h4>

<p>AVC Qt3 depends on
<a href="http://www.riverbankcomputing.co.uk/pyqt/">PyQt v3</a>
the python bindings for Qt v3 application framework. AVC Qt3 imports the
following modules from PyQt.</p>
<table class="ilcode">
<tr><td>import qt</td></tr>
</table>


<h4>Widget namimg</h4>

<p>Qt3 Designer and Qt3 <b>do not</b> allow duplicated naming of widgets.
So use the 'double underscore' mechanism to differentiate widgets names.</p>


<h4>Application class</h4>

<p>The application that uses AVC must be instantiated from an
application class that is derived from the
<span class="ilcode">QApplication</span> class and from the
<span class="ilcode">AVC</span> class.
Let suppose that the application class name is "theApp", the
application class statement will be
<span class="ilcode">class theApp(QApplication,AVC):</span>.</p>


<h3 id="qt4">Qt4</h3>

<p>This is the part of the reference manual specific to
<a href="http://www.trolltech.com/products/qt">Qt4</a>
widgets toolkit.</p>


<h4>Module dependencies</h4>

<p>AVC Qt4 depends on
<a href="http://www.riverbankcomputing.co.uk/pyqt/">PyQt v4</a>
the python bindings for Qt v4 application framework. AVC Qt4 imports the
following modules from PyQt.</p>
<table class="ilcode">
<tr><td>import PyQt4.Qt as qt</td></tr>
</table>


<h4>Widget namimg</h4>

<p>Qt3 Designer and Qt3 <b>do not</b> allow duplicated naming of widgets.
So use the 'double underscore' mechanism to differentiate widgets names.</p>


<h4>Application class</h4>

<p>The application that uses AVC must be instantiated from an
application class that is derived from the
<span class="ilcode">QApplication</span> class and from the
<span class="ilcode">AVC</span> class.
Let suppose that the application class name is "theApp", the
application class statement will be
<span class="ilcode">class theApp(QApplication,AVC):</span>.</p>


<hr>
<h2>Examples</h2>

<h3 id="a_simple_example_for_gtk">A simple example for GTK</h3>

<p>
<img alt="example1_gtk.png" src="example1_gtk.png">
This simple example shows how <b>AVC</b> can manage data
exchange from widget to widget without any specific code in the
application. The program creates a window with two widgets: a spin
button and a label. When the value in the spin button is changed by
clicking on up or down arrows or by entering it with the keyboard,
the new value is displayed into the label.</p>

<div class="code">

<h5>Python source of 'AVC GTK example 1'</h5>

<pre>
#!/usr/bin/python

import gtk				# gimp tool kit bindings
import gtk.glade			# glade bindings

<em>from avc.avcgtk import *</em>		# AVC for GTK

GLADE_XML = 'example1_gtk.glade'	# GUI glade descriptor


class Example(<em>AVC</em>):
  "A spin button whose value is replicated into a label"
  
  def __init__(self):
  
    # create GUI
    self.glade = gtk.glade.XML(GLADE_XML)
    
    # autoconnect GUI signal handlers
    self.glade.signal_autoconnect(self)
    
    # the variable holding the spin button value
    self.spin_value = 0


  def on_destroy(self,window):
    "Terminate program at window destroy"
    gtk.main_quit()


#### MAIN

example = Example()			# instantiate the application
<em>example.avc_init()</em>			# connect widgets with variables
gtk.main()				# run GTK event loop until quit
</pre>
</div>

<p>The GUI layout was previously edited with Glade and saved to the
file 'example1_gtk.glade'.</p>

<p>The key points of the example regarding <b>AVC</b> are
the following.</p>

<ul>
  <li>During Glade editing, the same name '<b>spin_value</b>' was given to
      the spin button and to the label.</li>
  <li>The specific <b>AVC</b> module for GTK is imported
      at program begin <br>
      (<span class="ilcode"><em>from avc.avcgtk import *</em></span>).</li>
  <li>The application class is derived from the <b>AVC</b> class
      (<span class="ilcode">class Example(<em>AVC</em>):</span>).</li>
  <li>A integer variable with an initial value of 0 a name '<b>spin_value</b>'
      is declared in the application
      (<span class="ilcode">self.spin_value = 0</span>).</li>
  <li>The avc_init method is called after the instantation of the
      application class, to realize the connections of the two widgets
      through the '<b>spin_value</b>' variable and to initialize the widgets
      values with the initial value of the variable
      (<span class="ilcode"><em>example.avc_init()</em></span>).</li>
</ul>

<p>Download the sample program
<a href="../examples/example1_gtk.py">example1_gtk.py</a></p>
and the Glade descriptor
<a href="../examples/example1_gtk.glade">example1_gtk.glade</a></p>


<h3 id="a_counter_example_for_gtk">A counter example for GTK</h3>

<p>
<img alt="example2_gtk.png" src="example2_gtk.png">
This example shows how <b>AVC</b> can manage data
input from a check button widget to the application and from the
application to a label widget without any specific code in the
application. The program creates a window with two widgets: a check
button and a label. The label displays the value of an integer
counter. The check button controls the increment speed of the
counter. Initially, it is unchecked meaning that the increment speed
of the counter is 2 units per second. When the user checks the
check button the increment speed grows to 10 units per seconds and
returns to the initial value (2) when the check button is unchecked
again.</p>

<div class="code">

<h5>Python source of 'AVC GTK example 2'</h5>

<pre>
#!/usr/bin/python

import gobject				#--
import gtk				#- gimp tool kit bindings
import gtk.glade			# glade bindings

<em>from avc.avcgtk import *</em>		# AVC for GTK

GLADE_XML = 'example2_gtk.glade'	# GUI glade descriptor
LOW_SPEED = 500				#--
HIGH_SPEED = 100			#- low and high speed period (ms)


class Example(<em>AVC</em>):
  """
  A counter displayed in a label widget whose count speed can be
  accelerated by checking a check button.
  """

  def __init__(self):

    # create GUI
    self.glade = gtk.glade.XML(GLADE_XML)

    # autoconnect GUI signal handlers
    self.glade.signal_autoconnect(self)

    # the counter variable and its speed status
    self.counter = 0
    self.high_speed = False

    # start counter incrementer at low speed
    gobject.timeout_add(LOW_SPEED,self.incrementer) 


  def incrementer(self):
    """
    Counter incrementer: increment period = LOW_SPEED, if high speed
    is False, increment period = HIGH_SPEED otherwise. Return False to
    destroy previous timer.
    """
    self.counter += 1
    if self.high_speed:
      period = HIGH_SPEED
    else:
      period = LOW_SPEED
    gobject.timeout_add(period,self.incrementer) 
    return False


  def on_destroy(self,window):
    "Terminate program at window destroy"
    gtk.main_quit()


#### MAIN

example = Example()			# instantiate the application
<em>example.avc_init()</em>			# connect widgets with variables
gtk.main()			 	# run GTK event loop until quit
</pre>
</div>

<p>The GUI layout was previously edited with Glade and saved to the
file 'example2_gtk.glade'.</p>

<p>The key points of the example regarding <b>AVC</b> are
the following.</p>

<ul>
  <li>During Glade editing, the name '<b>counter</b>' was given to
      the label and the name '<b>high_speed</b>' was given to the check
      button.</li>
  <li>The specific <b>AVC</b> module for GTK is imported
      at program begin <br>
      (<span class="ilcode"><em>from avc.avcgtk import *</em></span>).</li>
  <li>The application class is derived from the <b>AVC</b> class
      (<span class="ilcode">class Example(<em>AVC</em>):</span>).</li>
  <li>A integer variable with an initial value of 0 and name '<b>counter</b>'
      is declared in the application to hold the counter value
      (<span class="ilcode">self.counter = 0</span>).</li>
      A boolean variable with an initial value of False and name
      '<b>high_speed</b>' is declared in the application to hold the
      speed status of the counter increment
      (<span class="ilcode">self.high_speed = False</span>).</li>
  <li>The avc_init method is called after the instantation of the
      application class, to realize the connections between the
      '<b>counter</b>' variable and the label widget and between the
      the '<b>high_speed</b>' variable and the check button, the label
      widget is initialized with the initial value of the '<b>counter</b>'
      variable
      (<span class="ilcode"><em>example.avc_init()</em></span>).</li>
</ul>

<p>Download the sample program
<a href="../examples/example2_gtk.py">example2_gtk.py</a></p>
and the Glade descriptor
<a href="../examples/example2_gtk.glade">example2_gtk.glade</a></p>


<h3 id="a_complex_example_for_gtk">A complex example for GTK</h3>

<p>
<img alt="example3_gtk.png" src="example3_gtk.png">
This example shows a table of all widget/variable type
combinations supported by <b>AVC</b>. 
The program creates a window with three columns: the first shows
the type of the connected variable, the second shows all the widgets
that can be connected to that type of variable, the third shows the
current value of each variable.
Each row of the window represent a widgets/variable combination.
Row 1: memoryless button with boolean variable, pressed = True,
unpressed = False.
Row 2: buttons with memory, toggle and check buttons, pressed = True,
unpressed = False.
Row 3: radiobuttons numbered from 0 to 3, index variable = number
of checked radiobutton.
Row 4: integer input/output widgets, spin button and text entry.
Row 5: float input/output widgets, spin button and text entry.
Row 6: string input/output widget, text entry.
The text label widget is used in all output modes for the column of
the connected variable values.
The program increment the value of each connected variable looping
top-bottom at three rows per seconds. The user can also change the
connected variables interacting with the widgets.</p>

<div class="code">

<h5>Python source of 'AVC GTK example 3'</h5>

<pre>
#!/usr/bin/python

import gobject				#--
import gtk				#- gimp tool kit bindings
import gtk.glade			# glade bindings

<em>from avc.avcgtk import *</em>		# AVC for GTK

GLADE_XML = 'example3_gtk.glade'	# GUI glade descriptor
INCREMENTER_PERIOD = 333		# ms


class Example(<em>AVC</em>):
  "A table of all supported widget/control type combinations"

  def __init__(self):

    # create GUI
    self.glade = gtk.glade.XML(GLADE_XML)

    # autoconnect GUI signal handlers
    self.glade.signal_autoconnect(self)

    # the control variables
    self.boolean1 = False
    self.boolean2 = False
    self.radio = 0
    self.integer = 0
    self.float = 0.0
    self.string = ''

    # start variables incrementer
    increment = self.incrementer()
    gobject.timeout_add(INCREMENTER_PERIOD,increment.next)


  def incrementer(self):
    """
    Booleans are toggled, radio button index is rotated from first to last,
    integer is incremented by 1, float by 0.5, string is appended a char
    untill maxlen when string is cleared. Return True to keep timer alive.
    """
    while True:

      self.boolean1 = not self.boolean1
      yield True

      self.boolean2 = not self.boolean2
      yield True

      if self.radio >= 2:
        self.radio = 0
      else:
        self.radio += 1
      yield True

      self.integer += 1
      yield True

      self.float += 0.5
      yield True

      if len(self.string) >= 20:
        self.string = 'A'
      else:
        self.string += 'A'
      yield True


  def on_destroy(self,window):
    "Terminate program at window destroy"
    gtk.main_quit()


#### MAIN

example = Example()			# instantiate the application
<em>example.avc_init()</em>			# connect widgets with variables
gtk.main()			 	# run GTK event loop until quit
</pre>
</div>

<p>The GUI layout was previously edited with Glade and saved to the
file 'example3_gtk.glade'.</p>

<p>The key points of the example regarding <b>AVC</b> are
the following.</p>

<ul>
  <li>During Glade editing, the following names were given to the widgets.
      <table class="ilcode">
      <tr><th>widget</th><th>name</th></tr>
      <tr><td>Row 1:</td></tr>
      <tr><td>button</td><td><b>boolean1__button</b></td></tr>
      <tr><td>output value label</td><td><b>boolean1__var</b></td></tr>
      <tr><td>Row 2:</td></tr>
      <tr><td>togglebutton</td><td><b>boolean2__togglebutton</b></td></tr>
      <tr><td>checkbutton</td><td><b>boolean2__checkbutton</b></td></tr>
      <tr><td>output value label</td><td><b>boolean2__var</b></td></tr>
      <tr><td>Row 3:</td></tr>
      <tr><td>radiobutton0</td><td><b>radio__radiobutton0</b></td></tr>
      <tr><td>radiobutton1</td><td><b>radio__radiobutton1</b></td></tr>
      <tr><td>radiobutton2</td><td><b>radio__radiobutton2</b></td></tr>
      <tr><td>output value label</td><td><b>radio__var</b></td></tr>
      <tr><td>Row 4:</td></tr>
      <tr><td>spinbutton</td><td><b>integer__spinbutton</b></td></tr>
      <tr><td>entry</td><td><b>integer__entry</b></td></tr>
      <tr><td>output value label</td><td><b>integer__var</b></td></tr>
      <tr><td>Row 5:</td></tr>
      <tr><td>spinbutton</td><td><b>float__spinbutton</b></td></tr>
      <tr><td>entry</td><td><b>float__entry</b></td></tr>
      <tr><td>output value label</td><td><b>float__var</b></td></tr>
      <tr><td>Row 6:</td></tr>
      <tr><td>entry</td><td><b>string__entry</b></td></tr>
      <tr><td>output value label</td><td><b>string__var</b></td></tr>
      </table>
  <li>The specific <b>AVC</b> module for GTK is imported
      at program begin <br>
      (<span class="ilcode"><em>from avc.avcgtk import *</em></span>).</li>
  <li>The application class is derived from the <b>AVC</b> class
      (<span class="ilcode">class Example(<em>AVC</em>):</span>).</li>
  <li>A integer variable with an initial value of 0 a name '<b>spin_value</b>'
  <li>The following variables are declared in the application.
      <pre class="ilcode">
      self.boolean1 = False
      self.boolean2 = False
      self.radio = 0
      self.integer = 0
      self.float = 0.0
      self.string = ''</pre>
  <li>The avc_init method is called after the instantation of the
      application class, to realize the connections of all widegts/variable
      combinations and to initialize the widgets values with the initial
      value of the connected variable
      (<span class="ilcode"><em>example.avc_init()</em></span>).</li>
</ul>

<p>Download the sample program
<a href="../examples/example3_gtk.py">example3_gtk.py</a></p>
and the Glade descriptor
<a href="../examples/example3_gtk.glade">example3_gtk.glade</a></p>


<h3 id="a_simple_example_for_qt3">A simple example for Qt3</h3>

<p>
<img alt="example1_qt3.png" src="example1_qt3.png">
This simple example shows how <b>AVC</b> can manage data
exchange from widget to widget without any specific code in the
application. The program creates a window with two widgets: a spin
button and a label. When the value in the spin button is changed by
clicking on up or down arrows or by entering it with the keyboard,
the new value is displayed into the label.</p>

<div class="code">

<h5>Python source of 'AVC Qt3 example 1'</h5>

<pre>
#!/usr/bin/python

from qt import * 			# Qt interface
from qtui import *			# ui files realizer
import sys				# system support

<em>from avc.avcqt3 import *</em>		# AVC for Qt3

UI_FILE = 'example1_qt3.ui'


class Example(<em>QApplication,AVC</em>):
  "A spin box whose value is replicated into a text label"

  def __init__(self,sys_argv):

    # create GUI
    QApplication.__init__(self,sys_argv)
    self.root = QWidgetFactory.create(UI_FILE)
    self.setMainWidget(self.root)
    self.root.show()
    
    # the variable holding the spinbox value
    self.spin_value = 0


#### MAIN

example = Example(sys.argv)		# instantiate the application
<em>example.avc_init()</em>			# connect widgets with variables
example.exec_loop()			# run Qt event loop until quit
</pre>
</div>

<p>The GUI layout was previously edited with Qt3 Designer and saved to the
file 'example1_qt3.ui'.</p>

<p>The key points of the example regarding <b>AVC</b> are
the following.</p>

<ul>
  <li>During Qt3 Designer editing, the name '<b>spin_value__spinbox</b>'
      was given to the spin box and the name '<b>spin_value__label</b>'
      was given to the label.</li>
  <li>The specific <b>AVC</b> module for Qt3 is imported
      at program begin <br>
      (<span class="ilcode"><em>from avc.avcqt3 import *</em></span>).</li>
  <li>The application class is derived from the <b>QApplication</b> class
      of Qt3 and from the <b>AVC</b> class of AVC
      (<span class="ilcode">class Example(<em>QApplication,AVC</em>):</span>).
      </li>
  <li>A integer variable with an initial value of 0 a name '<b>spin_value</b>'
      is declared in the application
      (<span class="ilcode">self.spin_value = 0</span>).</li>
  <li>The avc_init method is called after the instantation of the
      application class, to realize the connections of the two widgets
      through the '<b>spin_value</b>' variable and to initialize the widgets
      values with the initial value of the variable
      (<span class="ilcode"><em>example.avc_init()</em></span>).</li>
</ul>

<p>Download the sample program
<a href="../examples/example1_qt3.py">example1_qt3.py</a></p>
and the UI descriptor
<a href="../examples/example1_qt3.ui">example1_qt3.ui</a></p>


<h3 id="a_counter_example_for_qt3">A counter example for Qt3</h3>

<p>
<img alt="example2_qt3.png" src="example2_qt3.png">
This example shows how <b>AVC</b> can manage data
input from a check button widget to the application and from the
application to a label widget without any specific code in the
application. The program creates a window with two widgets: a check
button and a label. The label displays the value of an integer
counter. The check button controls the increment speed of the
counter. Initially, it is unchecked meaning that the increment speed
of the counter is 2 units per second. When the user checks the
check button the increment speed grows to 10 units per seconds and
returns to the initial value (2) when the check button is unchecked
again.</p>

<div class="code">

<h5>Python source of 'AVC Qt3 example 2'</h5>

<pre>
#!/usr/bin/python

from qt import * 			# Qt interface
from qtui import *			# ui files realizer
import sys				# system support

<em>from avc.avcqt3 import *</em>		# AVC for Qt3

UI_FILE = 'example2_qt3.ui'
LOW_SPEED = 500				#--
HIGH_SPEED = 100			#- low and high speed period (ms)


class Example(<em>QApplication,AVC</em>):
  """
  A counter displayed in a Label widget whose count speed can be
  accelerated by checking a check box.
  """

  def __init__(self,sys_argv):

    # create GUI
    QApplication.__init__(self,sys_argv)
    self.root = QWidgetFactory.create(UI_FILE)
    self.setMainWidget(self.root)
    self.root.show()
    
    # the counter variable and its speed status
    self.counter = 0
    self.high_speed = False

    # start counter incrementer at low speed
    self.timer = qt.QTimer(self)
    self.connect(self.timer,qt.SIGNAL("timeout()"),self.incrementer)
    self.timer.start(LOW_SPEED)


  def incrementer(self):
    """
    Counter incrementer: increment period = LOW_SPEED, if high speed
    is False, increment period = HIGH_SPEED otherwise.
    """
    self.counter += 1
    if self.high_speed:
      period = HIGH_SPEED
    else:
      period = LOW_SPEED
    self.timer.stop()
    self.timer.start(period) 


#### MAIN

example = Example(sys.argv)		# instantiate the application
example.avc_init()			# connect widgets with variables
example.exec_loop()			# run Qt event loop until quit
</pre>
</div>

<p>The GUI layout was previously edited with Qt3 Designer and saved to the
file 'example2_qt3.ui'.</p>

<p>The key points of the example regarding <b>AVC</b> are
the following.</p>

<ul>
  <li>During Glade editing, the name '<b>counter</b>' was given to
      the label and the name '<b>high_speed</b>' was given to the check
      button.</li>
  <li>The specific <b>AVC</b> module for Qt3 is imported
      at program begin <br>
      (<span class="ilcode"><em>from avc.avcqt3 import *</em></span>).</li>
  <li>The application class is derived from the <b>QApplication</b> class
      of Qt3 and from the <b>AVC</b> class of AVC.
      (<span class="ilcode">class Example(<em>QApplication,AVC</em>):</span>).
      </li>
  <li>A integer variable with an initial value of 0 and name '<b>counter</b>'
      is declared in the application to hold the counter value
      (<span class="ilcode">self.counter = 0</span>).</li>
      A boolean variable with an initial value of False and name
      '<b>high_speed</b>' is declared in the application to hold the
      speed status of the counter increment
      (<span class="ilcode">self.high_speed = False</span>).</li>
  <li>The avc_init method is called after the instantation of the
      application class, to realize the connections between the
      '<b>counter</b>' variable and the label widget and between the
      the '<b>high_speed</b>' variable and the check button, the label
      widget is initialized with the initial value of the '<b>counter</b>'
      variable
      (<span class="ilcode"><em>example.avc_init()</em></span>).</li>
</ul>

<p>Download the sample program
<a href="../examples/example2_qt3.py">example2_qt3.py</a></p>
and the UI descriptor
<a href="../examples/example2_qt3.ui">example2_qt3.ui</a></p>


<h3 id="a_complex_example_for_qt3">A complex example for Qt3</h3>

<p>
<img alt="example3_qt3.png" src="example3_qt3.png">
This example shows a table of all widget/variable type
combinations supported by <b>AVC</b>. 
The program creates a window with three columns: the first shows
the type of the connected variable, the second shows all the widgets
that can be connected to that type of variable, the third shows the
current value of each variable.
Each row of the window represent a widgets/variable combination.
Row 1: memoryless button with boolean variable, pressed = True,
unpressed = False.
Row 2: buttons with memory, toggle and check buttons, pressed = True,
unpressed = False.
Row 3: radiobuttons numbered from 0 to 3, index variable = number
of checked radiobutton.
Row 4: integer input/output widgets, spin button and text entry.
Row 5: float input/output widgets, spin button and text entry.
Row 6: string input/output widget, text entry.
The text label widget is used in all output modes for the column of
the connected variable values.
The program increment the value of each connected variable looping
top-bottom at three rows per seconds. The user can also change the
connected variables interacting with the widgets.</p>

<div class="code">

<h5>Python source of 'AVC Qt3 example 3'</h5>

<pre>
#!/usr/bin/python

from qt import * 			# Qt interface
from qtui import *			# ui files realizer
import sys				# system support

<em>from avc.avcqt3 import *</em>		# AVC for Qt3


UI_FILE = 'example3_qt3.ui'
INCREMENTER_PERIOD = 333		# ms


class Example(<em>QApplication,AVC</em>):
  "A table of all supported widget/control type combinations"

  def __init__(self,sys_argv):

    # create GUI
    QApplication.__init__(self,sys_argv)
    self.root = QWidgetFactory.create(UI_FILE)
    self.setMainWidget(self.root)
    self.root.show()
    
    # the control variables
    self.boolean1 = False
    self.boolean2 = False
    self.radio = 0
    self.integer = 0
    self.float = 0.0
    self.string = ''
    
    # start variables incrementer
    self.increment = self.incrementer()
    self.timer = qt.QTimer(self)
    self.connect(self.timer,qt.SIGNAL("timeout()"),self.timer_function)
    self.timer.start(INCREMENTER_PERIOD)


  def timer_function(self):
    self.increment.next()


  def incrementer(self):
    """
    Booleans are toggled, radio button index is rotated from first to last,
    integer is incremented by 1, float by 0.5, string is appended a char
    untill maxlen when string is cleared.
    """
    while True:

      self.boolean1 = not self.boolean1
      yield True

      self.boolean2 = not self.boolean2
      yield True

      if self.radio == 2:
        self.radio = 0
      else:
        self.radio += 1
      yield True

      self.integer += 1
      yield True

      self.float += 0.5
      yield True

      if len(self.string) >= 20:
        self.string = 'A'
      else:
        self.string += 'A'
      yield True


#### MAIN

example = Example(sys.argv)		# instantiate the application
<em>example.avc_init()</em>			# connect widgets with variables
example.exec_loop()			# run Qt event loop until quit
</pre>
</div>

<p>The GUI layout was previously edited with Qt3 Designer and saved to the
file 'example3_qt3.ui'.</p>

<p>The key points of the example regarding <b>AVC</b> are
the following.</p>

<ul>
  <li>During Qt3 Designer editing, the following names were given to the
      widgets.
      <table class="ilcode">
      <tr><th>widget</th><th>name</th></tr>
      <tr><td>Row 1:</td></tr>
      <tr><td>button</td><td><b>boolean1__button</b></td></tr>
      <tr><td>output value label</td><td><b>boolean1__var</b></td></tr>
      <tr><td>Row 2:</td></tr>
      <tr><td>togglebutton</td><td><b>boolean2__togglebutton</b></td></tr>
      <tr><td>checkbutton</td><td><b>boolean2__checkbutton</b></td></tr>
      <tr><td>output value label</td><td><b>boolean2__var</b></td></tr>
      <tr><td>Row 3:</td></tr>
      <tr><td>radiobutton0</td><td><b>radio__radiobutton0</b></td></tr>
      <tr><td>radiobutton1</td><td><b>radio__radiobutton1</b></td></tr>
      <tr><td>radiobutton2</td><td><b>radio__radiobutton2</b></td></tr>
      <tr><td>output value label</td><td><b>radio__var</b></td></tr>
      <tr><td>Row 4:</td></tr>
      <tr><td>spinbutton</td><td><b>integer__spinbutton</b></td></tr>
      <tr><td>entry</td><td><b>integer__entry</b></td></tr>
      <tr><td>output value label</td><td><b>integer__var</b></td></tr>
      <tr><td>Row 5:</td></tr>
      <tr><td>spinbutton</td><td><b>float__spinbutton</b></td></tr>
      <tr><td>entry</td><td><b>float__entry</b></td></tr>
      <tr><td>output value label</td><td><b>float__var</b></td></tr>
      <tr><td>Row 6:</td></tr>
      <tr><td>entry</td><td><b>string__entry</b></td></tr>
      <tr><td>output value label</td><td><b>string__var</b></td></tr>
      </table>
  <li>The specific <b>AVC</b> module for Qt3 is imported
      at program begin <br>
      (<span class="ilcode"><em>from avc.avcqt3 import *</em></span>).</li>
  <li>The application class is derived from the <b>QApplication</b>
      class of Qt3 and from the <b>AVC</b> class of AVC
      (<span class="ilcode">class Example(<em>iQApplication,AVC</em>):</span>).
      </li>
  <li>A integer variable with an initial value of 0 a name '<b>spin_value</b>'
  <li>The following variables are declared in the application.
      <pre class="ilcode">
      self.boolean1 = False
      self.boolean2 = False
      self.radio = 0
      self.integer = 0
      self.float = 0.0
      self.string = ''</pre>
  <li>The avc_init method is called after the instantation of the
      application class, to realize the connections of all widegts/variable
      combinations and to initialize the widgets values with the initial
      value of the connected variable
      (<span class="ilcode"><em>example.avc_init()</em></span>).</li>
</ul>

<p>Download the sample program
<a href="../examples/example3_qt3.py">example3_qt3.py</a></p>
and the UI descriptor
<a href="../examples/example3_qt3.ui">example3_qt3.ui</a></p>


<h3 id="a_simple_example_for_qt4">A simple example for Qt4</h3>

<p>
<img alt="example1_qt4.png" src="example1_qt4.png">
This simple example shows how <b>AVC</b> can manage data
exchange from widget to widget without any specific code in the
application. The program creates a window with two widgets: a spin
button and a label. When the value in the spin button is changed by
clicking on up or down arrows or by entering it with the keyboard,
the new value is displayed into the label.</p>

<div class="code">

<h5>Python source of 'AVC Qt4 example 1'</h5>

<pre>
#!/usr/bin/python

from PyQt4.QtCore import *		# Qt core
from PyQt4.QtGui import *		# Qt GUI interface
from PyQt4.uic import *			# ui files realizer
import sys				# system support

<em>from avc.avcqt4 import *</em>		# AVC for Qt4

UI_FILE = 'example1_qt4.ui'


class Example(<em>QApplication,AVC</em>):
  "A spin box whose value is replicated into a text label"

  def __init__(self,sys_argv):

    # create GUI
    QApplication.__init__(self,sys_argv)
    self.root = loadUi(UI_FILE)
    #self.root.show()
    
    # the variable holding the spin box value
    self.spin_value = 0
    

#### MAIN

example = Example(sys.argv)		# instantiate the application
<em>example.avc_init()</em>			# connect widgets with variables
example.exec_()				# run Qt event loop until quit
</pre>
</div>

<p>The GUI layout was previously edited with Qt4 Designer and saved to the
file 'example1_qt4.ui'.</p>

<p>The key points of the example regarding <b>AVC</b> are
the following.</p>

<ul>
  <li>During Qt4 Designer editing, the name '<b>spin_value__spinbox</b>'
      was given to the spin box and the name '<b>spin_value__label</b>'
      was given to the label.</li>
  <li>The specific <b>AVC</b> module for Qt4 is imported
      at program begin <br>
      (<span class="ilcode"><em>from avc.avcqt4 import *</em></span>).</li>
  <li>The application class is derived from the <b>QApplication</b> class
      of Qt4 and from the <b>AVC</b> class of AVC
      (<span class="ilcode">class Example(<em>QApplication,AVC</em>):</span>).
      </li>
  <li>A integer variable with an initial value of 0 a name '<b>spin_value</b>'
      is declared in the application
      (<span class="ilcode">self.spin_value = 0</span>).</li>
  <li>The avc_init method is called after the instantation of the
      application class, to realize the connections of the two widgets
      through the '<b>spin_value</b>' variable and to initialize the widgets
      values with the initial value of the variable
      (<span class="ilcode"><em>example.avc_init()</em></span>).</li>
</ul>

<p>Download the sample program
<a href="../examples/example1_qt4.py">example1_qt4.py</a></p>
and the UI descriptor
<a href="../examples/example1_qt4.ui">example1_qt4.ui</a></p>


<h3 id="a_counter_example_for_qt4">A counter example for Qt4</h3>

<p>
<img alt="example2_qt4.png" src="example2_qt4.png">
This example shows how <b>AVC</b> can manage data
input from a check button widget to the application and from the
application to a label widget without any specific code in the
application. The program creates a window with two widgets: a check
button and a label. The label displays the value of an integer
counter. The check button controls the increment speed of the
counter. Initially, it is unchecked meaning that the increment speed
of the counter is 2 units per second. When the user checks the
check button the increment speed grows to 10 units per seconds and
returns to the initial value (2) when the check button is unchecked
again.</p>

<div class="code">

<h5>Python source of 'AVC Qt4 example 2'</h5>

<pre>
#!/usr/bin/python

from PyQt4.QtCore import *		# Qt core
from PyQt4.QtGui import *		# Qt GUI interface
from PyQt4.uic import *			# ui files realizer
import sys				# system support

<em>from avc.avcqt4 import *</em>		# AVC for Qt4


UI_FILE = 'example2_qt4.ui'
LOW_SPEED = 500				#--
HIGH_SPEED = 100			#- low and high speed period (ms)


class Example(<em>QApplication,AVC</em>):
  """
  A counter displayed in a Label widget whose count speed can be
  accelerated by checking a check box.
  """

  def __init__(self,sys_argv):

    # create GUI
    QApplication.__init__(self,sys_argv)
    self.root = loadUi(UI_FILE)
    
    # the counter variable and its speed status
    self.counter = 0
    self.high_speed = False

    # start counter incrementer at low speed
    self.timer = qt.QTimer(self)
    self.connect(self.timer,qt.SIGNAL("timeout()"),self.incrementer)
    self.timer.start(LOW_SPEED)


  def incrementer(self):
    """
    Counter incrementer: increment period = LOW_SPEED, if high speed
    is False, increment period = HIGH_SPEED otherwise.
    """
    self.counter += 1
    if self.high_speed:
      period = HIGH_SPEED
    else:
      period = LOW_SPEED
    self.timer.stop()
    self.timer.start(period) 


#### MAIN

example = Example(sys.argv)		# instantiate the application
<em>example.avc_init()</em>			# connect widgets with variables
example.exec_loop()			# run Qt event loop until quit
</pre>
</div>

<p>The GUI layout was previously edited with Qt4 Designer and saved to the
file 'example2_qt4.ui'.</p>

<p>The key points of the example regarding <b>AVC</b> are
the following.</p>

<ul>
  <li>During Qt4 Designer editing, the name '<b>counter</b>' was given to
      the label and the name '<b>high_speed</b>' was given to the check
      button.</li>
  <li>The specific <b>AVC</b> module for Qt4 is imported
      at program begin <br>
      (<span class="ilcode"><em>from avc.avcqt4 import *</em></span>).</li>
  <li>The application class is derived from the <b>QApplication</b> class
      of Qt4 and from the <b>AVC</b> class of AVC.
      (<span class="ilcode">class Example(<em>QApplication,AVC</em>):</span>).
      </li>
  <li>A integer variable with an initial value of 0 and name '<b>counter</b>'
      is declared in the application to hold the counter value
      (<span class="ilcode">self.counter = 0</span>).</li>
      A boolean variable with an initial value of False and name
      '<b>high_speed</b>' is declared in the application to hold the
      speed status of the counter increment
      (<span class="ilcode">self.high_speed = False</span>).</li>
  <li>The avc_init method is called after the instantation of the
      application class, to realize the connections between the
      '<b>counter</b>' variable and the label widget and between the
      the '<b>high_speed</b>' variable and the check button, the label
      widget is initialized with the initial value of the '<b>counter</b>'
      variable
      (<span class="ilcode"><em>example.avc_init()</em></span>).</li>
</ul>

<p>Download the sample program
<a href="../examples/example2_qt4.py">example2_qt4.py</a></p>
and the UI descriptor
<a href="../examples/example2_qt4.ui">example2_qt4.ui</a></p>


<h3 id="a_complex_example_for_qt4">A complex example for Qt4</h3>

<p>
<img alt="example3_qt4.png" src="example3_qt4.png">
This example shows a table of all widget/variable type
combinations supported by <b>AVC</b>. 
The program creates a window with three columns: the first shows
the type of the connected variable, the second shows all the widgets
that can be connected to that type of variable, the third shows the
current value of each variable.
Each row of the window represent a widgets/variable combination.
Row 1: memoryless button with boolean variable, pressed = True,
unpressed = False.
Row 2: buttons with memory, toggle and check buttons, pressed = True,
unpressed = False.
Row 3: radiobuttons numbered from 0 to 3, index variable = number
of checked radiobutton.
Row 4: integer input/output widgets, spin button and text entry.
Row 5: float input/output widgets, spin button and text entry.
Row 6: string input/output widget, text entry.
The text label widget is used in all output modes for the column of
the connected variable values.
The program increment the value of each connected variable looping
top-bottom at three rows per seconds. The user can also change the
connected variables interacting with the widgets.</p>

<div class="code">

<h5>Python source of 'AVC Qt4 example 3'</h5>

<pre>
#!/usr/bin/python

from PyQt4.QtCore import *		# Qt core
from PyQt4.QtGui import *		# Qt GUI interface
from PyQt4.uic import *			# ui files realizer
import sys				# system support

<em>from avc.avcqt4 import *</em>		# AVC for Qt4

UI_FILE = 'example3_qt4.ui'
INCREMENTER_PERIOD = 333		# ms


class Example(<em>QApplication,AVC</em>):
  "A table of all supported widget/control type combinations"

  def __init__(self,sys_argv):

    # create GUI
    QApplication.__init__(self,sys_argv)
    self.root = loadUi(UI_FILE)
    self.root.show()

    # group all radio buttons into a button group. Button group not
    # managed by Qt4 Designer ?!
    self.radio_button0 = self.root.findChild(QWidget,'radio__button0')
    self.radio_button1 = self.root.findChild(QWidget,'radio__button1')
    self.radio_button2 = self.root.findChild(QWidget,'radio__button2')
    self.radio_button_group = QButtonGroup()
    self.radio_button_group.addButton(self.radio_button0,0)
    self.radio_button_group.addButton(self.radio_button1,1)
    self.radio_button_group.addButton(self.radio_button2,2)
    
    # the control variables
    self.boolean1 = False
    self.boolean2 = False
    self.radio = 0
    self.integer = 0
    self.float = 0.0
    self.string = ''
    
    # start variables incrementer
    self.increment = self.incrementer()
    self.timer = QTimer(self)
    self.connect(self.timer,SIGNAL("timeout()"),self.timer_function)
    self.timer.start(int(INCREMENTER_PERIOD))


  def timer_function(self):
    self.increment.next()


  def incrementer(self):
    """
    Booleans are toggled, radio button index is rotated from first to last,
    integer is incremented by 1, float by 0.5, string is appended a char
    untill maxlen when string is cleared.
    """
    while True:

      self.boolean1 = not self.boolean1
      yield True

      self.boolean2 = not self.boolean2
      yield True

      if self.radio == 2:
        self.radio = 0
      else:
        self.radio += 1
      yield True

      self.integer += 1
      yield True

      self.float += 0.5
      yield True

      if len(self.string) >= 20:
        self.string = 'A'
      else:
        self.string += 'A'
      yield True


#### MAIN

example = Example(sys.argv)		# instantiate the application
<em>example.avc_init()</em>			# connect widgets with variables
example.exec_()				# run Qt event loop until quit
</pre>
</div>

<p>The GUI layout was previously edited with Qt4 Designer and saved to the
file 'example3_qt4.ui'.</p>

<p>The key points of the example regarding <b>AVC</b> are
the following.</p>

<ul>
  <li>During Qt4 Designer editing, the following names were given to the
      widgets.
      <table class="ilcode">
      <tr><th>widget</th><th>name</th></tr>
      <tr><td>Row 1:</td></tr>
      <tr><td>button</td><td><b>boolean1__button</b></td></tr>
      <tr><td>output value label</td><td><b>boolean1__var</b></td></tr>
      <tr><td>Row 2:</td></tr>
      <tr><td>togglebutton</td><td><b>boolean2__togglebutton</b></td></tr>
      <tr><td>checkbutton</td><td><b>boolean2__checkbutton</b></td></tr>
      <tr><td>output value label</td><td><b>boolean2__var</b></td></tr>
      <tr><td>Row 3:</td></tr>
      <tr><td>radiobutton0</td><td><b>radio__radiobutton0</b></td></tr>
      <tr><td>radiobutton1</td><td><b>radio__radiobutton1</b></td></tr>
      <tr><td>radiobutton2</td><td><b>radio__radiobutton2</b></td></tr>
      <tr><td>output value label</td><td><b>radio__var</b></td></tr>
      <tr><td>Row 4:</td></tr>
      <tr><td>spinbutton</td><td><b>integer__spinbutton</b></td></tr>
      <tr><td>entry</td><td><b>integer__entry</b></td></tr>
      <tr><td>output value label</td><td><b>integer__var</b></td></tr>
      <tr><td>Row 5:</td></tr>
      <tr><td>spinbutton</td><td><b>float__spinbutton</b></td></tr>
      <tr><td>entry</td><td><b>float__entry</b></td></tr>
      <tr><td>output value label</td><td><b>float__var</b></td></tr>
      <tr><td>Row 6:</td></tr>
      <tr><td>entry</td><td><b>string__entry</b></td></tr>
      <tr><td>output value label</td><td><b>string__var</b></td></tr>
      </table>
  <li>The specific <b>AVC</b> module for Qt4 is imported
      at program begin <br>
      (<span class="ilcode"><em>from avc.avcqt4 import *</em></span>).</li>
  <li>The application class is derived from the <b>QApplication</b>
      class of Qt3 and from the <b>AVC</b> class of AVC
      (<span class="ilcode">class Example(<em>iQApplication,AVC</em>):</span>).
      </li>
  <li>A integer variable with an initial value of 0 a name '<b>spin_value</b>'
  <li>The following variables are declared in the application.
      <pre class="ilcode">
      self.boolean1 = False
      self.boolean2 = False
      self.radio = 0
      self.integer = 0
      self.float = 0.0
      self.string = ''</pre>
  <li>The avc_init method is called after the instantation of the
      application class, to realize the connections of all widegts/variable
      combinations and to initialize the widgets values with the initial
      value of the connected variable
      (<span class="ilcode"><em>example.avc_init()</em></span>).</li>
</ul>

<p>Download the sample program
<a href="../examples/example3_qt4.py">example3_qt4.py</a></p>
and the UI descriptor
<a href="../examples/example3_qt4.ui">example3_qt4.ui</a></p>


<h3><hr></h3>
<p>&copy; Copyright 2006-2007 by Fabrizio Pollastri</p>
</body>
</html>
